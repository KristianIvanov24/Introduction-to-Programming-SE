# Динамична памет

## Видове памет
### **Stack - Стекова памет**
- Предварително определен размер
- Паметта се заделя ПРЕДИ компилация на програмата.
- Паметта се освобождава/трие/маркира като свободна автоматично - при излизането от scope-а,  в който е дефинирана.

### **Static - Статична памет** 
- Паметта се заделя преди стартиране на програмата.
- Съществува през целия живот на програмата.
- Не е нито stack, нито heap

```c++
int globalX = 5;        // статична памет
static int counter = 0; // статична памет
```

### **Heap - Динамична памет** 
- Паметта се заделя по време на изпълнение на програмата(runtime).
- Масиви и обекти без предварително да е известна големината.

![image](https://drive.google.com/uc?id=1VHTSM4F_1z9o5BKG75Vk-nBfIkWnl0RI)

## Dynamic memory
### Оператор **new**
- Заделя памет от свободната част на heap със ст-сти по подразбиране
- Връща указтел към началото на паметта
```c++
new <data_type>([<size>])opt;
```
- изразът заделя динамично памет за ```size``` елемента от даден тип ```data_type``` 
- ```size``` - не е задължително да е константа
- ```data_type``` - всеки познат ни тип данни

```c++
int* p = new int; // заделя памет за един int, без ст-ст
*p = 5;

int* p1 = new int(); // заделя памет за един int и инициализира ст-ст 0
cout << *p1; // 0

int* arr = new int[6]; // динамичен масив, заделя памет за 6 цели числа, ст-стите са неопределени
int* arr1 = new int[5]{}; // динамичен масив, заделя памет за 5 цели числа, всички елементи са 0
int ptr = new int[4] {1, 2, 3}; // създаваме масив за 4 цели числа, тези които не са инициализирани са 0
```
- Заделянето на динамична памет е много "бавна" операция!!
- Динамична памет НЕ се трие автоматично.
- Ако няма достатъчно свободна памет при заделяне, то се хвърля грешка ```std::bad_alloc```

### **Оператор delete[]** - освобождава/маркира като свободна динамична памет!

```c++
void f()
{
  int x = 40;
  char ch[2] = {'a', 'b'};
  int* ptr = new int[3];
}
```

![enter image description here](https://i.ibb.co/vYdR6Zj/dyn-mem.png)

След приключването на функцията ще се изчисти паметта в стека, но НЕ и паметта в heap-а.

За това ние трябва ръчно да я маркираме като свободна.

```c++
void f()
{
  int x = 40;
  char ch[2] = {'a', 'b'};
  int* ptr = new int[3];
  delete[] ptr; //!!!!!!!
}
```

### Невалидни операции с delete
```c++
int x;
int* p = &x;
delete p;       // stack memory

int* a = new int[10];
delete (a + 3); // частично освобождаване

int* q = new int;
delete q;
delete q;       // double delete

int* arr = new int[5];
delete arr;       // грешка, памет заделена с new[] се освобождава с delete[]

int* b = new int;
delete[] b;     // грешка, памет заделена с new се освобождава с delete
```

### Memory leak
```c++
int* p = new int[10];
p = new int[20]; // загубихме адреса към първия масив

// Правилно:
int* p = new int[10];
delete[] p;
p = new int[20];
```

### Dangling Pointer
Когато освободим заделена памет, но указателят ни продължава да сочи към същия адрес 
```c++
int* ptr = new int[5];

// Deallocating memory
delete ptr;

std::cout <<*ptr;
```
- За да избегнем проблема, в който се опитване да достъпим памет, която вече е освободена, пренасичваме указателя към ```nullptr```
```c++
int* ptr = new int[5];

delete ptr;
ptr = nullptr;
```

### Примери:

 - Да се напише функция, която приема стринг и връща нов стринг с ТОЧНА ГОЛЕМИНА, в който всички числа са цензурирани. (Всяко число е заменено с '*')
 - Да се напише функция, която приема стринг и връща два стринга с ТОЧНА големина. Първият да бъде съставен само от малките букви, а другият да бъде съставен само от главните букви.

<h3>Задачи</h3>

**Задача 1:** Да се напише функция, която приема масив от целия числа, който е получен след конкатенация на два сортирани масив, и го сортира. (без сортиращи алгоритми)

**Задача 2:** Напишете функция, която приема масив от цели числа и цяло число и елемент на масива. Функцията да преподрежда елементите, така че всички по-малки елементи от подадения да са в ляво от него, а всички по-големи - в дясно. (Забележка: Задачата да се реши с помощта на допълнителен масив - същестува и решение без допълнителна памет (Hoare's partition, Lomuto partition и други), но то не се изисква)

*Вход: [1, 5, 6, 3, 0, -1, 2, 9, 7] ,3* *Изход: [1, 0, 2, ,-1, 3, 6, 5, 9, 7]*
