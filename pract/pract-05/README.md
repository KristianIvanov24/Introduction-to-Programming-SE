### Теория

1. Какво ще отпечата следният код?
```C++
#include <iostream>

bool f() {
    std::cout << 5;
    return false;
}

bool g() {
    std::cout << 123;
    return true;
}

bool h() {
    std::cout << 0;
    return true;
}

void k()
{
    std::cout << (h() || g() || f()) << std::endl;
    std::cout << (g() && f() && h()) << std::endl;
}

int main()
{
    k();
}
```
<details> <summary> Отговор </summary> 

01<br>
12350

За `h() || g() || f()`:<br>
- `h()` се извиква първо -> извежда 0, връща true<br>
- `||` прилага short-circuit evaluation (мързеливо обработване на булеви изрази) след първия true -> `g()` и `f()` не се извикват<br>
- Резултатът на израза е true -> при извеждане се печата 1<br>

За `g() && f() && h()`:<br>
- `g()` се извиква -> извежда 123, връща true<br>
- `f()` се извиква -> извежда 5, връща false<br>
- `&&` short-circuit-ва след false от `f()` -> `h()` не се извиква<br>
- Резултатът на израза е false -> при извеждане се печата 0<br>
</details>

2. Какво ще отпечата следният код?
```C++
#include <iostream>

int main() {
    int a = 10;
    int& b = a;
    b++;
    int c = b;
    c--;
    std::cout << a << " " << b << " " << c;
}
```
<details> <summary> Отговор </summary>

11 11 10

`int a = 10` -> a = 10<br>
`int& b = a` -> b е reference към a, т.е. `b` и `a` са едно и също нещо (едно и също място в паметта)<br>
`b++` -> увеличава `a` чрез `b`, a = b = 11<br>
`int c = b` -> c = 11<br>
`c--` -> намалява c, c = 10<br>
Извеждаме a, b, c -> 11 11 10<br>

</details>

3. Какво ще отпечата следният код?
```C++
void f(int& a = 0) {
    std::cout << a << std::endl; 
}

int main() {
    f();
}
```
<details> <summary> Отговор </summary> 

Компилационна грешка

Функцията `f` има параметър `int& a` със стойност по подразбиране 0<br>
Не може да се направи референция към стойност (0 е rvalue), C++ изисква референция да сочи към lvalue<br>
</details>

4. Какво ще отпечата следният код?
```C++
#include <iostream>

void f(int a) {
	std::cout << "f(int)" << std::endl;
}

void f(char a) {
	std::cout << "f(char)" << std::endl;
}

int main()
{
	std::cout << f(3.0);
}
```
<details> <summary> Отговор </summary>

Компилационна грешка

Подаваме 3.0 (double) на `f`<br>
Има двa overload-а на `f`: `f(int)` и `f(char)`<br>
И двете могат да се извикат чрез implicit преобразование на `double` към `int` и `char`<br>
Компилаторът не знае коя да избере -> грешка<br>

</details>

5. Какво ще отпечата следният код?
```C++
#include <iostream>

int sum(int a, int b)
{
	std::cout << "sum(int, int)" << std::endl;
	return a + b;
}

double sum(double a, double b)
{
	std::cout << "sum(double, double)" << std::endl;
	return a + b;
}

int main()
{
	std::cout << sum(4, 5) << std::endl;
	std::cout << sum(4.12, 5.13) << std::endl;
	std::cout << sum(4, 1.0) << std::endl;
	std::cout << sum(4.0, 1) << std::endl;
	return 0;
}
```
<details> <summary> Отговор </summary>

Компилационна грешка на редовете: `sum(4, 1.0)` `sum(4.0, 1)`

Компилаторът трябва да избере измежду overload-ите `sum(int, int)` и `sum(double, double)`<br>
При `sum(4, 1.0)` -> първият аргумент е `int`, вторият `double`<br>
И дветата overload-а на функцията могат да се извикат чрез implicit преобразуване, съответно компилаторът не знае коя да извика<br>
Същото важи и за `sum(4.0, 1)`<br>
</details>

6. Какво ще отпечата следният код?
```C++
#include <iostream>
using namespace std;

int g() {
    return f();
}

int f() {
    return 0;
}

int main() {
    std::cout << g();
}
```
<details> <summary> Отговор </summary> 

Компилационна грешка

`g()` извиква `f()`, но в момента на декларацията на `g`, `f()` още не е дефинирана<br>
В C++ една функция трябва да бъде декларирана или дефинирана преди да се използва<br>
Тъй като `f()` се дефинира след `g()`, компилаторът не знае за нея -> грешка при компилация<br>

</details>

### В час

1. Напишете функция, която приема неотрицателни числа n и k и връща дали k е префикс на n.

Вход: 288, 28, Изход: true

2. Напишете функция, която приема число и връща най-малката и най-голяма цифра на число.

### Задачи
1. Напишете функция, която приема символ и ако символът е цифра, да върне съответната цифра. Ако символът не е цифра, то да върне -1

2. Да се напише функция countDigits(int number), която връща колко цифри има даденото число.

3. Напишете функция, която приема естествено число и връща дали цифрите му са еднакви.

4. Функция bool isPerfect(int n), която проверява дали числото е перфектно
(сборът на всички негови делители без самото число е равен на него).

5. Да се напише функция getRemainder(int first, int second), която играе ролята на оператор % (за делене с остатък), т.е. връща като резултат first % second. Не може да използвате оператор % за тази задача!

6. Да се напише функция isSymmetricDigitSet(int n)
която връща true, ако цифрите на n образуват „симетрично множество“,
т.е. ако за всяка цифра d в n, цифрата 9 - d също присъства.

7. Функция bool isArmstrong(int n) – проверява дали сумата на цифрите на n, повдигнати на степен броя на цифрите, е равна на самото число.

8. Функция bool isStrong(int n), която проверява дали сборът от факториелите на цифрите на n е равен на самото n.

9. Напишете функция getDigitByPosition(int n, int k), която връща цифрата на позиция k в n (отляво надясно, броим от 1).

10. Напишете фунцкия, която по подадени 3 цели числа a, b и k прехвърля последните k цифри на a в началото на b.

11. Напишете функция, която приема неотрицателни числа n и k и връща дали k е суфикс на n.

Вход: 288, 88, Изход: true

12. Напишете функция, която приема неотрицателни числа n и k и връща дали k е инфикс в n.

Вход: 2831, 83, Изход: true

13. Напишете функция, която дадено по подадено естествено число N, връща число, което е резултат от конкатенацията на обърнатото число на N с подаденото N.

14. Да се напише фунцкия bool permutationNumbers(int a, int b), която връща дали числата a и b са пермутации едно на друго.
