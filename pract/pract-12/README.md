# Теория

1. Какъв е проблема в следното парче код?
```c++
char** createMatrix(int rows, int cols) {
    char** matrix = new char*[rows];
    for (int i = 0; i < rows; i++) {
        matrix[i] = new char[cols];
    }
    return matrix;
}

int main() {
    char** mat = createMatrix(10, 10);
    delete[] mat;
}
```

2. Какъв е проблема в следното парче код?
```c++
char* getLonger(char* s1, char* s2) {
    if (strlen(s1) > strlen(s2)) {
        char result[100];
        strcpy(result, s1);
        return result;
    }
    return s2;
}

int main() {
    char* str1 = new char[6];
    strcpy(str1, "Hello");
    char* str2 = new char[3];
    strcpy(str2, "Hi");
    
    char* longer = getLonger(str1, str2);
    std::cout << longer;
    
    delete[] str1;
    delete[] str2;
}
```

3. Какъв е проблема в следното парче код?
```c++
void processStrings(char** strings, int count) {
    for (int i = 0; i < count; i++) {
        delete[] strings[i];
    }
}

int main() {
    char** arr = new char*[3];
    arr[0] = new char[5];
    strcpy(arr[0], "Test");
    
    arr[1] = arr[0];
    
    arr[2] = new char[5];
    strcpy(arr[2], "Data");
    
    processStrings(arr, 3);
    delete[] arr;

    return 0;
}
```

4. Какъв е проблема в следното парче код?
```c++
int main() {
    int* num = new int(5);
    char* text = new char[5];
    strcpy(text, "Hello");
    
    delete[] num;
    delete text;
}
```

5. Какъв е проблема в следното парче код?
```c++
char* findWord(char** words, int count, char letter) {
    for (int i = 0; i < count; i++) {
        if (words[i][0] == letter) {
            char* result = words[i];
            delete[] words[i];
            return result;
        }
    }
    return nullptr;
}

int main() {
    char** words = new char*[2];
    words[0] = new char[6]; 
    strcpy(words[0], "apple");
    words[1] = new char[7]; 
    strcpy(words[1], "banana");
    
    char* found = findWord(words, 2, 'b');
    std::cout << found;
}
```


# Задачи

**1.** Да се напише функция, която приема цяло число n и връща заделен целочислен масив с такъв размер.

**2.** Да се напише функция, която приема цели числа n и m и връща заделена целочислена матрица с такива размери.

**3.** Да се напише функция, която приема 2 символни низа и връща нов символен низ, за който е заделено точно количество памет, който представлява конкатенация на малките букви в първия и главните във втория .

**4.** Да се напише функция, която приема матрица и връща нейната транспонирана.

**5.** Да се напише функция, която приема матрица и индекс i и връща нова матрица, за която е заделено точно количество памет, в която липсва i-тия ред. 

**Пример:**

Вход:
```
1 2 3 
4 5 6
7 8 9
1
```

Изход:
```
1 2 3 
7 8 9
```

**6.** Да се напише функция, която приема 2 масива от цели числа с произволна големина, както и число К. Програмата да връща нов масив, за който е заделено точно количество памет, който да е съставен само от числата, съдържащи се в двата масива, които се делят на К.

**Пример:**

Вход:
```c++
[2 4 5 8]
[3 16 7 9 10]
2
```

Изход:
```c++
[2 4 8 16 10]
```

**7.** Да се напише функция, която приема масив с произволна дължина и връща нов масив, за който е заделено точно количество памет, който е съставен само от елементите, които се делят на поне 1 от съседите си.

**Пример:**

Вход:
```c++
[5 10 20 4 2 7]
```
Изход:
```c++
[10 20 4 2]
```

**8.** Да се напише функция, която приема естествено число n и два низа с дължина n, и да връща нов низ, за който е заделено точно количество памет представляващ най-дългия общ префикс на двата входни масива.

**Пример:**

Вход:
```c++
5
aaabb
aabab
```
Изход:
```c++
Низ с дължина 3 и стойност {'a', 'a', '\0'}.
```

**9.** Да се напише функция, която приема символен низ, и връща нов низ, за който е заделено точно количество памет, в който са премахнати всички повтарящи се символи.

**Пример:**

Вход:
```c++
aklahk3g*5ggkkks
```
Изход:
```c++
lh3*5s
```

**10.** Да се напише функция, която приема символен низ, масив от цели числа с произволна дължина, представляващи позиции в символния низ, и символ S. Функцията да връща нов символен низ, за който е заделено точно количество памет, в който на всяка една от дадените позиции е вмъкнат символът S.

**Пример:**

Вход:
```c++
Hi here nice o mee you.
[3 13 18]
t
```
Изход:
```c++
Hi there nice to meet you.
```

**11.** Да се напише функция, която приема стринг с произволна дължина и връща като резултат нов стринг, за който е заделено точно количество памет, представляващ конкатенацията на първата и последната дума от подадения, като двете думи да са разделени с интервал.

**Пример:**

Вход:
```c++
Hello hi hey
```
Изход:
```c++
Hello hey
```

**12.** Да се напишат следните функции за работа със символни низове:
- `char** split(const char* str, char separator)` - приема низ и разделител и връща масив от всички низове, образувани от разбиването на оригиналния спрямо разделителя
- `char* removeWord(const char* str, int index)` - приема низ и връща нов, в който е премахната думата на индекс `index` от стария
- `char* swapWords(const char* str, int fIndex, int sIndex)` - приема низ и връща нов, в който са разменени позициите на думите на индекси `fIndex` и `sIndex`

**13.** Да се напише функция, която приема два сортирани масива връща нов трети масив, за който е заделено точно количество памет, като поддържа сортировката. За задачата НЕ може да използвате сортиращи алгоритми.

**14.** Да се напише функция, която приема масив от числа и връща масив от масиви, които представляват всички подмножества на подадения масив.

**15.** Да се напише функция, която приема символен низ и връща нов символен низ, за който е заделено точно количество памет, в който всички символи са сортирани в нарастващ ред по тяхната ASCII стойност.

**Пример:**

Вход:
```c++
programming
```
Изход:
```c++
aggimmnoprr
```

**16.** Алгоритъмът за компресия Rип Length Encoding (RLE) компресира символни низове, несъдържащи цифри, като замести всяка непрекъсната последователност от еднакви символи X в тях с низа XN, където N е дължината на последователността. Единичните символи не се заменят. Реализирайте функция, която компресира текст, несъдържащ цифри, посредством RLE алгоритъма и връща получения резултат в низ с точната големина.

**Пример:**

Вход:
```
wwwwaaadexxxxxxywwwaa
```
Изход:
```
w4a3dex6yw3a2
```
