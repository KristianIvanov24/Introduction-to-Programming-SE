# Теория

Когато приемаме масив във функция, ако функцията няма да го модифицира, задължително го приемаме като константа!!!
```C++
void print(const int[] arr, size_t size) {
    ...
}

void reverse(int[] arr, size_t size) {
    ...
}
```
---
Aгрегатна инициализация (aggregate initialization) на масив:
```c++
// --- 1 ---
int global[5];
// [0, 0, 0, 0, 0]
// глобалните масиви са на по-специално място в паметта и се инициализират с 
// default-ни стойности автоматично

int main() {
    // --- 2 ---
    int nums[5]; 
    bool nums[5];
    // undefined behaviour

    // --- 3 ---
    int nums[5] = { 0 };
    // [0, 0, 0, 0, 0];

    bool nums[5] = { false };
    // [false, false, false, false, false]

    // --- 4 ---
    int nums[5] = { 1 };
    // [1, 0, 0, 0, 0]

    int nums[5] = { 1, 2, 3 };
    // [1, 2, 3, 0, 0]

    bool nums[5] = { true };
    // [true, false, false, false, false]
}
```

Стойности по подразбиране при aggregate initialization:
| Type  | any number type | char  | bool  |
| ----- | :-------------: | :---: | :---: |
| Value |        0        | '\0'  | false |

---
```c++
void func(char a) { std::cout << a; } // 1

void func(int a) { std::cout << a; } // 2

void func(char a, int b) { std::cout << a << '-' << b; } // 3

void func(double a, char b) { std::cout << b << '-' << a; } // 4

void func(bool a) { std::cout << a; } // 5

void func(char a, bool b, int c) { std::cout << a << b << c; } // 6

void func(const int a) { std::cout << a; } // 7

void func(char a, unsigned b) { std::cout << a << '-' <<b; } // 8

char func(char a) { return a; } // 9
```

<details> <summary>Отговор</summary>

- От 1 до 6 няма проблеми - параметрите или са от различен вид, или са с различен брой.<br>
- 7 clash-ва с 2 - const параметри участват в различаването на функции, само когато подаваме по референция (адрес), а тук подаваме по копие(`func(int&)` и `func(const int&)` биха се различавали без проблем).<br>
- 9 clash-ва с 1, понеже return типът на функцията не се използва за различаване между функции (не е част от сигнатурата на функция - име и брой/тип на параметри), а останалото (името и парамтерите) е еднакво при двете.

</details>  

# В час

1. Напишете фунцкия, която приема масив от цели числа и добавя елемент на индекс `pos`

2. Напишете функция, която отпечатва всички прости числа в интервала `[1, n]`, (`n <= 1023`).

# Задачи

1. Напишете функция, която приема масив от цели числа и връща дали е сортиран.

2. Напишете фунцкия, която приема масив от цели числа и премахва елемент на индекс `pos`.

3. Напишете функция, която приема масив от цели числа и число `k`, и обръща първите `k` елемента на масива.

4. Напишете функция, която приема **сортиран** масив от цели числа и връща медианата му. Медиана е средния елемент на сортиран масив. Ако масива е с четна дължина медианата е средноаритметичното на двата елемента в средата.

5. Напишете функция, която приема масив от цели числа и връща минимума и максимума.

6. Напишете функция, която приема масив от цели числа и размера му, и премахва отрицателните елементи.

7. Напишете функция `int findZero(const int[] arr, size_t size)`, която приема масив от цели числа, в който първо са разположени нечетни числа, след тях има точно една нула, а след нея - четни числа, и връща индекса на тази нула или -1, ако такава няма.
Задачата да се реши оптимално, без да се обхождат последователно всички елементи на масива.

8. Напишете функция `bool canBePartitioned(const int arr[], size_t size)`, която да връща `true`, ако масивът може да бъде разделен на две части, с равни суми на елементите им и `false` - в противен случай.

9. Напишете функция, която приема масив и връща дължината на най-дългата подредица от еднакви числа и числото от подредицата. Ако има две най-дълги редици с еднаква дължина да върне числото от първата такава.

<details> 
<summary> Примерен вход и изход </summary>

Вход:
```
[1 1 2 2 2 3 3 2 2]
```
Изход:
```c++
3 // length
2 // number
```
---
Вход:
```
[9 9 9 9 1 1 1 1]
```
Изход:
```
4 
9 
```
---
Вход:
```
[2 9 1 1] 
```
Изход:
```
2 
1 
```
</details>

10. Напишете функция, която приема 2 масива, съставени само от цифрите от 0 до 9, с еднаква дължина. Функцията да връща дали вторият масив е пермутация на първия.

<details> <summary> Примерен вход и изход</summary>

Вход:  
```
[0, 1, 1, 5, 6, 6], [1, 6, 0, 1, 5, 6]
```

Изход:
```
true
```

Вход:  
```
[0, 1, 7, 8, 9], [1, 6, 0, 1, 5, 6]
```

Изход:
```
false
```

</details>

11. Напишете функция, която приема два масива от цели числа и проверява дали вторият масив е подмасив на първия.

<details> <summary> Примерен вход и изход </summary>

Вход:
```
[4 6 7 5 8 9] // size = 6
[6 7] // size = 2
```
Изход:
```
true
```
---
Вход:
```
[47 8 5 7 9 1] // size = 6
[8 9 1] // size = 3
```
Изход:
```
false
```
</details>


12. Напишете фунцкия `void printSubarrays(const int[] arr, int size, int k)`, където `k ≤ size` и принтира всички подмасиви с дължина `k`.

<details> <summary> Примерен вход и изход</summary>

Вход: 
```
[1, 2, 3, 4, 5], k = 3
```

Изход:
```
1 2 3
2 3 4
3 4 5
```

</details>


13. Напишете функция, която приема два сортирани масива и ги слива в трети масив като поддържа сортировката.

<details> <summary> Примерен вход и изход </summary>

Вход:
```
[1 3 5 7]
[2 4 6 8]
```
Изход
```
[1 2 3 4 5 6 7 8]
```
---
Вход:
```
[2 2 3 4 6]
[1 2 5]
```
Изход:
```
[1 2 2 2 3 4 5 6]
```
---
Вход:
```
[3 9]
[3 5 6 8]
```
Изход:
```
[3 3 5 6 8 9]
```
</details>

14. Да се напишат функции, които приемат два масива (множества) и връщат обединениетo, сечението и разликата на двете множества.

15. Да се напишат функции, които приемат два масива `X` и `Y` от цели числа с еднаква дължина `n`, които представляват бинарната релация: <br>
`R ⊆ X × Y`, `R = { (xi​,yi​) ∣ xi ∈ X; yi ∈ Y | i=0, 1, …, n−1 }` (елементите на индекс `i` в `X` са в релация с елементите на индекс `i` в `Y`).<br>
Фунцкиите да връщат съответно дали релацията е рефлексивна, симетрична, антисеметрична, транзитивна

<details> <summary> Примерен вход и изход </summary>

Вход:
```c++
[1 2 3 4 1 3] // X
[2 1 4 3 1 3] // Y
// R = { (1, 2), (2, 1), (3, 4), (4, 3), (1, 1), (3, 3) }
```
Изход
```
Reflexive: no
Symmetric: yes
Antisymmetric: no
Transitive: no
```

Вход:
```c++
[1 2 3] // X
[1 2 3] // Y
// R = { (1, 1), (2, 2), (3, 3) }
```
Изход:
```
Reflexive: yes
Symmetric: yes
Antisymmetric: yes
Transitive: yes
```

Вход:
```c++
[1 2 3] // X
[1 3 3] // Y
// R = { (1, 1), (2, 3), (3, 3) }
```
Изход:
```
Reflexive: no
Symmetric: no
Antisymmetric: yes
Transitive: yes
```

</details>
