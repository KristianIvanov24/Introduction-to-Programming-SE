# Рекурсия. Алгоритми. Сложност на алгоритмите

## Рекурсия
Рекурсия е програмна техника, при която даден метод извиква сам себе си при решаването на определен проблем. Такива методи наричаме рекурсивни.

- **Дъно на рекурсия** - реализирайки рекурсия, трябва да сме сигурни, че след краен брой стъпки ще получим конкретен резултат.
Трябва да имаме един или няколко случаи, чието решение можем да намерим директно, без рекурсивно извикване. Тези случаи наричаме дъно на рекурсията.
Ако даден рекурсивен метод няма дъно на рекурсията, рекурсията ще стане безкрайна и резултатът ще е ***StackOverflowException***.
- **Видове рекурсия:**
    - **Пряка рекурсия** - когато в тялото на метод се извършва извикване на същия метод, казваме, че методът е пряко рекурсивен.
    - **Косвена рекурсия** - ако метод A се обръща към метод B, B към C, а С отново към А, казваме, че методът А, както и методите В и C са непряко (косвено) рекурсивни или взаимно-рекурсивни.

## Разлика м/у рекурсия и цикъл

| **Рекурсията**                                                                                              | **Циклите**                                                                                                  |
|-------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| Рамка в стековата памет се алокира при всяко едно извикване на функцията.                                   | Можете да използвате цикли и без да създавате отделна функция.                                              |
| Получава се "верига" от много стекови рамки, докато се достигне дъното на рекурсията.                       | При всяка итерация в цикъла не се създава нова рамка и не се заема непрекъснато още памет.                  |
| Рекурсията заема много памет, защото се пазят всички стекови рамки, докато не се достигне дъното.           | Обикновено имат по-ниска константна времева сложност.                                              |

| **Рискове при рекурсията**                                                                                  | **Рискове при циклите**                                                                                     |
|-------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| **StackOverFlow** - няма повече стекова памет, в която да се заделят нови рамки (от там идва и името на форума). | Може да се получи в някои частни случаи безкраен цикъл.                                                     |
| **OutOfMemory** - няма повече Heap памет, в която да се заделя за рекурсивните обекти, които се инициализират вътре в рекурсивната функция. |                                                                                                             |

**Препоръка:** Ако за решаването на някаква задача е уместно да се използва итеративен алгоритъм, реализирайте го.
Не се препоръчва винаги използването на рекурсия, тъй като това води до големи загуби на памет.

### Примери:
- Да се реализира рекурсивна функция, която пресмята n!
- Да се реализира рекурсивна функция, която вдига число на дадена степен.

## Сложност на алгоритмите
Сложността на алгоритъма показва как се променят времето за изпълнение и използваната памет в зависимост от размера на входните данни.
- **Размер на входа** – най-често се означава с ***n***
- Анализът се прави в **най-лошия случай**

### Сложност по време (Time Complexity)
Показва броя операции, които алгоритъмът извършва. 

Използва се **Big-O нотация**.
- **O(1)** – константна сложност
- **O(n)** – линейна сложност
- **O(n²)** – квадратична сложност
- **O(log n)** – логаритмична сложност
- **O(2ⁿ)** – експоненциална сложност

### Сложност по памет
Показва количеството допълнителна памет, която алгоритъмът използва.

## Алгоритми
Алгоритъмът е крайна последователност от действия, които водят до
решаване на даден проблем чрез обработка на данни и изчисления.

- Алгоритми за търсене - вече сме разглеждали
    - Линейно търсене - **O(n)**
    - Двоично търсене (рекурсивно) - **O(log n)**
- Алгоритми за сортиране:
    - Bubble sort - **O(n²)**
    - Insertion sort - **O(n²)**
    - Selection sort - **O(n²)**

## Задачи:
**Задача 1:** Да се реализира рекурсивна функция, която пресмята n-тото число на фибоначи.

**Задача 2:** Да се реализира рекурсивна функция, която приема масив от цели числа и връща сумата на елементите в него.

**Задача 3:** Да се реализира рекурсивна функция, която приема стринг и връща дали стрингът е палиндром.

**Задача 4:** Да се сортира масив от цели числа по брой цифри в числата. Числа с еднакъв брой цифри да се подреждат във възходящ ред.
